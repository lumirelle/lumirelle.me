---
title: 'Project Engineering: Manually Split Chunks'
date: 2025-11-05T16:22+08:00
update: 2025-11-06T00:09+08:00
lang: en
duration: 5min
type: blog+note
---

[[toc]]

## Introduction

As a modern front-end developer, you may be very familiar with the word "chunks splitting".

> [!NOTE]
>
> "Module", "bundle" and "chunk" are the concepts from Webpack, but they are also widely used in other modern
> builders/bundlers.
>
> - A "module" is any source file in your project (like `.js`, `.ts`, `.vue`, and even though a `.css`, `.svg`, etc.).
> - A "bundle" is the output file generated by the builder/bundler, which contains the compiled result of one or more
>   modules.
>
>   If **an entry module** `import` another module, the output bundle will contain two modules, otherwise will contain
>   only one module.
>
>   If a module is never been used by any entry module, it will not been compiled into any bundle, this called "tree
>   shaking".
>
>   Example:
>
>   _entry.js_
>
>   ```js
>   import { foo } from './module.js'
>
>   console.log(foo)
>   ```
>
>   _module.js_
>
>   ```js
>   export const foo = 'Hello, World!'
>   ```
>
>   This "entry module" will output a bundle contain the compiled result of both `entry.js` and `module.js`.
>
>   _entry-standlone.js_
>
>   ```js
>   console.log('Hello, World!')
>   ```
>
>   This "entry module" will output a bundle contain only the compiled result of `entry-standlone.js`.
>
>   _module-never-been-used.js_
>
>   ```js
>   export const foo = 'Hello, World!'
>   ```
>
>   This "unused module" will not been included in any bundle.
>
> - A "chunk" is a part of a bundle, which can be loaded independently.
>
>   By default, modern builders/bundlers (I just test Webpack 5 & Vite 7) will extract **async modules** from the
>   bundle, so that the output bundle are been split into multiple chunks, and each chunk has the compiled result of one
>   or more modules.

This is a technique that allows you to split the output "bundles" into smaller "chunks", which can be loaded
independently. This can reduce the initial bundle size and improve the loading performance of first screen.

The key point of using this technique is how to balance the **size of** the chunks and the **number of** chunks.

- If the chunks are too large, the initial loading time may become too long.
- If the chunks are too small, there will be a large number of chunks to load, which may cause the request waterfall.
- Both of the above two edge cases will degrade the loading performance.

Happily, modern builders/bundlers have already provided some default split strategies (like max chunk size, min chunk
size, etc.) for us to use. These strategies are suitable for most of the cases, so we don't need to (I mean, we
**shouldn't to**) change these strategies at most of the time, unless you have special needs and you really know what
you are doing.

Change these default strategies casually will let you get in trouble with the two edge cases mentioned above.

So why we still should care about chunks splitting? Because there is still one thing we **can & must** do: "chunks
grouping".

## Why should we do chunks grouping?

If you are familiar with the principle of the modern builders/bundlers, you may know that the modern builders/bundlers
will attach file hash to each output file, so that we (actually, it's the browser) can identify the file version easily.

In our front-end project, we may use some third-party dependencies, just like `vue`, `bignumber.js`, etc. And we
`import` them in our source code.

For this default case, some output chunks may contain the compiled result of both our source code and the dependencies'
code. Every time we change the source code and re-build our project, the hash of these chunks will always change, and
the cache on the CDN will be always invalidated.

If we extract all of the dependencies into some independent chunks, things will be better:

In most cases, the dependencies of our front-end project will not change in a long time, so the hash of the chunks
corresponding to these dependencies will not change. Benefited from this, the CDN can work much better, because it can
cache these chunks for a longer time.

## How to group chunks?

For different builders/bundlers, the way to group chunks is different.

### Webpack

For Webpack, we can use the `optimization.splitChunks.cacheGroups` in the configuration (like `webpack.config.js`) to
group chunks.

_webpack.config.js_

```js
export default {
  output: {
    /**
     * Webpack does not attach hash to chunk files by default, so we should configure it manually.
     */
    filename: '[name]-[fullhash].js',
  },
  optimization: {
    splitChunks: {
      /**
       * We want apply cache groups to both `async` and `initial` chunks, so we should use `chunks: 'all'`.
       */
      chunks: 'all',
      cacheGroups: {
        // Extract large vendors into a separate chunk.
        'e-charts': {
          name: 'echarts',
          test: /[\\/]node_modules[\\/]echarts(.*)/,
          priority: 30,
        },
        'element-plus': {
          name: 'element-plus',
          test: /[\\/]node_modules[\\/]element-plus(.*)/,
          priority: 20,
        },
        // Extract common vendors into a separate chunk.
        'vendor': {
          name: 'vendor',
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true,
        },
        // Extract common source code (used by more than 1 chunk) into a separate chunk.
        'default': {
          name: 'default',
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
}
```

### Vite

For Vite, we can use the `build.rollupOptions.output.chunkFileNames` in the configuration (like `vite.config.ts`) to
group chunks.

_vite.config.ts_

```ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          // Extract large vendors into a separate chunk.
          if (id.match(/[\\/]node_modules[\\/]echarts(.*)/)) {
            return 'echarts'
          }
          if (id.match(/[\\/]node_modules[\\/]element-plus(.*)/)) {
            return 'element-plus'
          }
          // Extract common vendors into a separate chunk.
          if (id.match(/[\\/]node_modules[\\/]/)) {
            return 'vendor'
          }
          return null
        },
      },
    },
  },
})
```

### Example

See [this example repository](https://github.com/lumirelle/manually-split-chunks) for a complete implementation.
